unsigned char read,trig,cont;

void key_scan(void)
{
	read = PINB ^ 0xFF;
	trig = read & (read ^ cont);
	cont = read;
}

/* 解释原理：
每个按键上拉电阻，按下时接地。PINB为GPIOB的寄存器按位取值。
场景1：当PINB都没有按下时：
read = 0xFF ^ 0xFF = 0x00
trig = 0x00 & (0x00 ^ 0x00) = 0x00
cont = 0x00
结论：三个变量都为0x00

场景2：当PB1长按没松开时：
read = 0xFE ^ 0xFF = 0x01
trig = 0x01 & (0x01 ^ 0x00) = 0x01
cont = 0x01

再次扫描：
read = 0xFE ^ 0xFF = 0x01
trig = 0x01 & (0x01 ^ 0x01) = 0x00
cont = 0x01
结论：trig在长按下只会置1一次，cont为长按保持值

场景3：当PB1长按松开时：
read = 0xFF & 0xFF = 0x00
trig = 0x00 & (0x00 ^ 0x01) = 0x00
cont = 0x00
结论:不管是点按还是长按松开后，三个变量都为0x00

消抖处理：延时一段时间确认前后两次按钮值一样确认按下。
*/